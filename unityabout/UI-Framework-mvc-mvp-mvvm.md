#   M-V-C

全名是Model View Controller,是模型(model),视图(view),控制器(cotroller)的缩写,是一种软件设计典范,是一种业务逻辑。架构的兴起有他的时代背景和意义,但随着时代的变迁,工具,大环境甚至是目标设备都可能发生发生变化,所以一框架也是需要逐步调整的。MVC的出现源于操作系统和软件的日益复杂化。MFC或者VB那种界面和逻辑糅和在一起的模式已经远远不能满足大型复杂的功能开发。随着软件行业的日益成熟，团队的职能分工也越来越明确，那么如何将揉在一起的任务拆离出来，让不同职能的人专注于自己的领域和设计也是一个重要的方面。基于很多原因，软件UI框架开始分化为M-V-C的模式。M层专注于数据处理， V层专注于数据的表现形式，按个人意愿以柱状图、饼状图或是表格来呈现。

一个典型的MVC的框架可以这么表示：

![ui_mvc](E:\GitHub\mdFile\images\ui_mvc.png)

此处强烈推荐Unity的Animator编辑器，使用十分方便。

可以看到这是一个局部生态的自给自足。这里考虑了大部分的交互和变更情况，并通过规定每个部分的职能来满足功能需求。

但是MVC并不是完美的。严格来说，它只是一种指导性的框架，是综合了大部分的软件需求和时代发展得出的较优的方案。但这种模式仍然存在缺陷：

（1）局部生态，数据（M层）封闭，如果多个模块需要同一个数据块，数据之间的互通和重用性都非常低效。

（2）局部耦合，虽然在大环境下实现了局部封闭，但是局部内的各个层之间的逻辑耦合还是很深。

想象一下，如果把上面的局部展示放大到游戏开发中会是什么样？

![ui_mvc2](E:\GitHub\mdFile\images\ui_mvc2.png)

在这个情境下，MVC的框架就不能很好地应对了。游戏数据很多时候是互相依赖，并不能完全封闭。比如：角色的属性展示需要用到背包里的装备，背包需要显示货币，货币可能受某些角色属性影响，任务依赖角色等级，同时奖励货币和道具、装备等等。

那么这种情况下，MVC要么需要将M写得非常复杂，每遇到一个新的需求开出一个新的接口，提供数据查询或者变更；要么写一个通用的M管理器，用来统一中转数据。

在游戏开发这种需求多变、数据嘈杂的背景下，无论哪种都不能很好地应对需求，开发人员会受到“无尽的折磨”，在遵循架构和实现需求之间来回纠结、摩擦，最终写得不伦不类，Bug还超多。

# M-V-P

有需求就要有变化，当一个需求只是个别现象的时候，你可以特殊处理、特殊对待。但需求大批量出现的时候，就得重新审视现在的实现是不是需要重构或者升级了。

MVP即Model-View-Presenter。

Model的工作就是完成对数据的操纵，数据的获取、存储、数据状态变化都是Model层的任务，如：网络请求，持久化数据增删改查等任务。View只处理视图相关，不做任何逻辑处理。Presenter作为桥梁，处理二者之间的所有中转。

![mvp](E:\GitHub\mdFile\images\mvp.png)

在这个模式下，M和V的连接被完全切断了，以前C层只是负责一些简单的转发和处理，现在P的任务变得更重，除了桥梁的作用之外，还需要做初步甚至高级的逻辑处理来处理M-V或者V-M的交流过程。

既然P的任务变重了，那么相对来说，P也会变得更加臃肿和难以维护，但带来好处是将M和V彻底解耦，不管哪一方的实现方式发生变化，只要最终和P同步的数据不变，另一方都不需要关心和修改。

既然P的任务变重了，那么相对来说，P也会变得更加臃肿和难以维护，但带来好处是将M和V彻底解耦，不管哪一方的实现方式发生变化，只要最终和P同步的数据不变，另一方都不需要关心和修改。

# M-V-VM

MVVM是Model-View-ViewModel的简写。

![MVVM](E:\GitHub\mdFile\images\MVVM.png)

从示意图上来看，最直观的感受是两个：

（1）使用ViewModel替代了Presenter。

（2）原本P和V一对一的关系现在变为VM-V一对多的关系。

这解决了什么问题呢？

（1）VM在一定程度上能够重用，就表示M层在一定程度上也可以复用了。

（2）VM一对多的关系，表示在类和文件的数量和管理上要减轻很多。

VM是通过[DataBinding](https://www.jianshu.com/p/d3d8f842b5ec)的技术，实现V和M之间的关系映射，抛弃了P层的手动关系接口和维护。当然每种技术都有其存在的意义和要解决的问题，至于选取什么样的方案去解决问题，就要看项目自己的需求更符合哪一类的设计。如果都没有那就需要自己去实现变种或者是新的设计，当然也可以修改需求。

1.1 游戏开发应该使用什么？

注意，以上的三种方法都是来源于软件，都是来源于软件，都是来源于软件。游戏开发中也都是套用这些概念来进行UI开发设计的。至于实现过程，依据引擎和平台的差别肯定是不一样的，那么我们使用什么样的方式呢？

我的UI框架设计里，没有使用DataBinding技术，如果要仔细归类，它可能不属于以上的任意一种。那么我给它命名为MVE，即Model-View-Event。

MVC重点逻辑在V，MVP重点逻辑在P，MVVM的重点逻辑是在V和VM，V负责UI逻辑部分，VM负责数据绑定部分。那么MVE可以认为是MVC的一个变种，但是V会和数据中心共享。

话不多说看图：

![mvvm2](E:\GitHub\mdFile\images\mvvm2.png)

作为网络游戏来说，数据应该来自两个部分，一部分是策划编辑的数据，一部分是通过服务器下发的数据。界面通过注册事件来订阅指定的事件类型，数据中心通过和服务器之间的交互来获得或者改变数据，并根据需求推送指定的Event。当界面关心的事件发生，它有两种可能：一部分是动态变化的局部更新，可以通过事件带下来；另外一种是整体数据需要去数据中心获取。

举个例子，当我打开背包界面的时候，我需要知道所有的背包数据，因此V和M直接交互，拿到背包的所有道具，并显示自己。然后我吃掉了一个经验丹，这时候服务器会告诉客户端删除一个物品，这个时候数据层会通过事件触发，背包监听了这个事件，并且查找对应的道具ID，删除，然后对背包道具进行局部重新排列刷新。

假设我们还有一个界面叫做一键升级，可以选择吃掉背包内不同种类的经验丹，那么它打开的时候同样找数据中心拿取道具这部分相关的数据做显示，如果这个时候在背包内吃掉一个，那么同样监听了这条消息的一键升级界面也要重新显示数量。

所以V和M的关系只是查询，并不会改变数据，数据的变化只能来自于服务器的协议驱动（当然一些客户端自定义的、用于辅助的数据，比如：排序列表、计时器等View层，自己变化就好）。

另外，其实开篇我也有提到，这里再提下：

M-V- X本质都是一样的，重点在于M-V的桥梁，要靠X来牵线。

在相同技术栈下，能够实现的各种X可以说都是大同小异的。

在不同技术栈下，相同X的实现却是大相径庭，仅有非常抽象的流程类似。

再者，不管是框架还是设计模式都是为了解决实际问题的，不需要也不应该为了设计而过度设计，但是也不能完全没有章法，胡乱定义。

一个稳定的、有序的、能满足项目需求的实现就是好的实现。切莫过度纠结设计模式和框架结构，但是也不能轻视这部分，够用就好。



