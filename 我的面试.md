# 渲染管线的流程

1. 本地坐标->视图坐标->背面裁剪->光照->裁剪->投影->视图变换->光栅化

![image-20211012164944225](C:\Users\12746\AppData\Roaming\Typora\typora-user-images\image-20211012164944225.png)

![image-20211012164935598](C:\Users\12746\AppData\Roaming\Typora\typora-user-images\image-20211012164935598.png)

# 光源的类型以及不同点

- Directional light： 方向光，类似太阳的日照效果。
- Point light： 点光源，类似蜡烛。
- Spotlight： 聚光灯，类似手电筒。
- Area Light：区域光，无法用作实时光照，一般用于光照贴图烘培。

# 什么光源有阴影以及原理

阴影是可以设置的  ，即光源都可以产生阴影

# unity-apk是跑在安卓上的主线程吗？

Unity运行自己的线程来处理它的任务。当启动应用程序时，它不会占用Android操作系统创建的Android主线程。通常，当你编写一个传统的Android应用程序时，只有一个主线程，所有处理UI的东西都必须在主线程上运行。使用第二个“主线程”是Unity的设计选择，这样它就可以在不干扰应用Android主线程的情况下做任何它想做的事情。如果你想在Unity之外的Android UI中做任何事情，你需要让你的代码在主线程上运行。

# 工作中遇到的问题：

1. lua与c#的通信卡顿问题。 
2. UI卡顿问题

# class与struct 的区别

1. 

# c#是如何lua通信的？

		1. lua与其他语言交互，都是通过操作虚拟栈交流的。而操作虚拟栈最原始的方法就是通过lua与c语言的api；
  		2. 一方把数据放到栈顶 另一方对数据进行操作 先把数据都出栈 把执行结果再放入栈 一方再去获取栈顶的数据

#  lua C++++  position 传值经历了什么?

**1. C#中拿到Vector3的x、y、z三个值；**
**2. Push这3个float给Lua栈；**
**3. 然后构造一个表，将表的x,y,z赋值；**
**4. 将这个表push到返回值里。**

#  sdk的接入流程，，比如登录模块？

1. Android部分
   1. 创建Android项目;
   2. 添加unity安装目录下的classes.jar包 并添加依赖
   3. 配置AndroidManifest.xml文件
   4. gradle目录配置
   5. MainActive修改
   6. 创建打包jks文件并转换为 keystore 文件
   7. 编译打出arr包
2. SDK配置
   1. 
3. unity部分
   1. 创建项目，编写代码，配置Android打包环境  配置playersetting 数据  打apk包

# 用到了哪些数据结构， list的底层是如何实现的

# DrawCall的计算方法

# UI是如何进行顺序渲染的

# 图集为什么可以降低DrawCall

# canvas  layer层 和order sort一致时  渲染的顺序是根据创建的顺序进行渲染  后创建的会覆盖掉先创建的

# 简历基本问了一个遍

# 项目用到的网络协议是什么 ？ http tcp udp  是长链接  短连接

# 背景贴图，背景音乐内存占用情况

# 手机发烫的原因有哪些

1. 常见的情况一个是CPU占满了，逻辑运算量非常大；还有一个就是带宽占满了，譬如说有大量的texture fetch... 
2. 像shader复杂度之类的有一定影响
3. cpu满负荷运行
   带宽填满
   频繁io
   渲染面积太大
   fps设置过高
   unity projectsetting，quality setting设置错误
   复杂的脚本
   物理计算
   不靠谱的策划
   不遵守美术规范的美术
   只管完成功能的程序

# 游戏 服务端和客户端是如何交互的

# 如何规划 动态合批  静态合批

1. 静态合批采用了以空间换时间的策略来提升渲染效率。

   1. Unity中把物体标记为Static，然后开启静态合批
   2. 限制
      - 需要保持static，不能改变transform
      - 使用相同材质的物体才能合批
      - 一个批次上限为~15k个顶点

2. ​	动态合批的限制条件呢？

   ●材质球相同；

   ●Mesh顶点数量不能超过300以及顶点属性不能超过900；

   ●缩放不能为负值（x、y、z向量的乘积不能为负）等。	

3. Unity自带动态合批，需要在Unity中开启动态合批选项
   会导致cpu消耗，如果不是gpu有瓶颈，最好关闭动态合批
   前提
     使用顶点位置、法线、UV0、UV1和切线为一个着色器提供180个顶点
     使用顶点位置、法线和单一UV的着色器的300个顶点

4. 动态合批与静态合批的区别

   1. 动态合批不会创建常驻内存的“合并后网格”，也就是说它不会在运行时造成内存的显著增长，也不会影响打包时的包体大小；
   2. 动态合批在绘制前会先将顶点转换到世界坐标系下，然后再填充进顶点、索引缓冲区；静态合批后子网格不接受任何变换操作，仅手动合批后的Root节点可被操作，因此静态合批的顶点、索引缓冲区中的信息不会被修改（Root的变换信息则会通过Constant Buffer传入）；
   3. 因为2的原因，动态合批的主要开销在于遍历顶点进行空间变换时的对CPU性能的开销；静态合批没有这个操作，所以也没有这个开销；
   4. 动态合批使用根据渲染器类型分配的公共缓冲区，而静态合批使用自己专用的缓冲区。

1. 在不同平台下ab包 或者图片的格式是什么？

   1. [(8条消息) unity各个平台对图片压缩格式的选择和图片的尺寸要求_Unity博客-CSDN博客](https://blog.csdn.net/XiangZuoZouzou/article/details/99220951)
   2. 内存计算方式
      1. 使用RGBA 32bit真彩，占用内存 = 4Bytes*512*512 = 1MB;
      2. 使用RGB ETC 4bit压缩，占用内存 = 0.5Bytes*512*512 = 128KB。

   # 项目给自身所带来的东西有什么 比如技术 经验  沟通等

   # 热更新的机制

   1. 热更新就是**动态下发代码**，它可以使开发者在不发布新版本的情况下，修复 BUG 和发布功能，让开发者得以绕开苹果的审核机制，避免长时间的审核等待以及多次被拒造成的成本。
   2. 使用lua热更新就是在Unity环境里内嵌一个lua虚拟机，经常变动的和对执行效率没要求的逻辑用Lua实现，游戏启动时加载服务器上最新的lua字节码来执行游戏。 lua代码都是运行时才编译的，不运行的时候就如同一张图片、一段音频一样，都是文件资源；所以更新逻辑只需要更新脚本，不需要再编译，因而lua能轻松实现“热更新”。





